# gits: git history search
function gits() {
  # Check if a search string was passed
  if [[ -z "$1" ]]; then
    echo "Usage: gits <string-to-search-in-git-history>"
    return 1
  fi

  local search_string=$1

  git log --all --pickaxe-regex -S "$search_string" --pretty=format:"%C(yellow)%h%Creset -%C(auto)%d%Creset %s %C(green)(%cr) %C(bold blue)<%an>%Creset" | fzf --ansi --no-sort --preview="git show --color=always {1}" --preview-window=right:70%:wrap | awk '{print $1}'
}

function gc() {
  git commit -v -a -m "$*"
}

function gd() {
  git difftool $1 -t Kaleidoscope -y
}

function gbt() {
  git checkout -b $1 --track origin/$1
}

git-add-origin() {
  local remote_name="${1:-origin}"
  local repo_name=$(gh repo view --json name --jq '.name')
  git remote add "$remote_name" "https://github.com/iloveitaly/$repo_name.git"
}

function git-squash-custom-branch {
  # Check if the .git-custom-branch file exists
  if [[ ! -f ".git-custom-branch" ]]; then
    echo "Error: .git-custom-branch file does not exist"
    exit 1
  fi

  # Check for unstaged changes
  if [[ -n "$(git diff --name-only)" ]]; then
    echo "Error: You have unstaged changes. Please commit or stash them."
    exit 1
  fi

  # determine if master is main, or actually master
  local master_branch=$(git branch -l master main | sed 's/^* //' | xargs)

  # Checkout to the master branch
  git checkout $master_branch

  # Pull the latest changes from the master branch
  git pull origin $master_branch

  # Check if the 'custom' branch already exists and delete it if it does
  if git show-ref --verify --quiet refs/heads/custom; then
    git branch -D custom
  fi

  # Read the branch names from the .git-custom-branch file
  branches=($(<.git-custom-branch))

  # Check if there's at least one branch
  if [[ ${#branches[@]} -eq 0 ]]; then
    echo "Error: .git-custom-branch file is empty"
    exit 1
  fi

  # Check if there's more than one branch
  if [[ ${#branches[@]} -eq 1 ]]; then
    echo "Error: .git-custom-branch file contains only one branch (${branches[1]}). At least two branches are required for merging."
    exit 1
  fi

  # Checkout to a new branch named 'custom' from the latest master
  git checkout -b custom

  git merge "${branches[@]}" --no-ff --message "Merged and squashed ${branches[@]}"
}

# TODO should probably remove
# https://blog.takanabe.tokyo/en/2020/04/remove-squash-merged-local-git-branches/
function git-clean-squash-and-merge() (
  set -euo pipefail

  # xargs to trim whitespace https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
  local master_branch=$(git branch -l master main | sed 's/^* //' | xargs)
  echo "Using $master_branch as master"

  git checkout -q $master_branch
  git for-each-ref refs/heads/ "--format=%(refname:short)" | while read branch; do
    local ancestor=$(git merge-base $master_branch $branch)

    if [[ $(git cherry main $(git commit-tree $(git rev-parse $branch'^{tree}') -p $ancestor -m _)) == "-"* ]]; then
      git branch -D $branch
    fi
  done
)
# if a PR is closed when it shouldn't have been, reopen it with one click!
# commonly happens with the annoying stale bots
github_reopen_pr() {
  local PR_URL="$1"
  local REPO PR_NUMBER PR_DETAILS TITLE BODY HEAD_REF

  REPO=$(echo $PR_URL | awk -F '/pull/' '{print $1}' | sed 's|https://github.com/||')
  PR_NUMBER=$(echo $PR_URL | awk -F '/pull/' '{print $2}')
  PR_DETAILS=$(gh pr view $PR_NUMBER --repo $REPO --json title,body,headRefName,headRepositoryOwner)
  BASE_BRANCH=$(gh repo view $REPO --json defaultBranchRef --jq '.defaultBranchRef.name')

  TITLE=$(jq -r .title <<<"$PR_DETAILS")
  BODY=$(jq -r .body <<<"$PR_DETAILS")
  HEAD_REF=$(jq -r .headRefName <<<"$PR_DETAILS")
  HEAD_REPO_OWNER=$(jq -r .headRepositoryOwner.login <<<"$PR_DETAILS")

  gh pr create --web --repo "$REPO" --title "$TITLE" --body "$BODY" --head "$HEAD_REPO_OWNER:$HEAD_REF" --base "$BASE_BRANCH"
}

# add a license to an existing project/repo, both as a license file and license metadata
add_mit_license() {
  # Check if the current folder is tied to a GitHub repository
  if ! gh repo view >/dev/null 2>&1; then
    echo "This folder is not tied to a GitHub repository. Aborting."
    return 1
  fi

  # Check if any LICENSE file exists
  if [[ -e LICENSE || -e LICENSE.md || -e LICENSE.txt ]]; then
    echo "A LICENSE file already exists. Aborting."
    return 1
  fi

  local license_template
  local repo_info
  local repo_name
  local author
  local year

  # Fetch the MIT license template
  license_template=$(gh api /licenses/MIT --jq '.body')

  # Get repository details
  repo_info=$(gh repo view --json nameWithOwner --jq '.nameWithOwner')
  repo_name=$(basename "$repo_info")
  author=$(git config user.name)
  year=$(date +%Y)

  # Replace placeholders in the license template
  local license_content
  license_content=${license_template//\[year\]/$year}
  license_content=${license_content//\[fullname\]/$author}

  # Write the license to LICENSE.md
  echo "$license_content" >LICENSE.md

  echo "MIT License added to the repository."
}

# render readme content on clipboard and replace username and repo
# useful for custom templates I have in my notes
render-git-template() {
  local GH_USERNAME=$(gh repo view --json owner --jq '.owner.login' | tr -d '[:space:]')
  local GH_REPO=$(gh repo view --json name --jq '.name' | tr -d '[:space:]')
  local TEMPLATE=$(pbpaste)

  TEMPLATE=${TEMPLATE//USERNAME/$GH_USERNAME}
  TEMPLATE=${TEMPLATE//REPO/$GH_REPO}
  echo $TEMPLATE | tr -ds '\n' ' '
}

# extracts all file(s) in a git repo path into PWD. Helpful for lifting source from an existing open source project.
# usage: git-extract https://github.com/vantezzen/shadcn-registry-template/blob/main/scripts/
git-extract() {
  local url=$1
  # Extract owner/repo/branch/path from GitHub URL
  local parts=(${(s:/:)${url/https:\/\/github.com\//}})
  local owner=$parts[1]
  local repo=$parts[2]
  local branch=$parts[4]
  local filepath=${(j:/:)parts[5,-1]}

  # Build tarball URL and folder name
  local tarball="https://github.com/$owner/$repo/archive/refs/heads/$branch.tar.gz"
  local foldername="$repo-$branch"

  # Extract just the specified path
  curl -L $tarball | tar xz --strip=1 "$foldername/$filepath"
}

# request review on a PR
gh-assign-reviewer() {
    # Check if there is a PR for the current branch
    PR_NUMBER=$(gh pr view --json number --jq '.number' 2>/dev/null)
    if [ -z "$PR_NUMBER" ]; then
        echo "Error: No PR found for the current branch."
        return 1
    fi

    # Get the PR API URL
    PR_URL=$(gh pr view --json url --jq '.url')

    # Get the list of possible assignees
    POSSIBLE_ASSIGNEES=$(gh api repos/:owner/:repo/assignees --jq '.[].login' | tr ' ' '\n')

    # Prepare the header for fzf with PR URL and instruction
    FZF_HEADER="PR: $PR_URL"$'\n'"Select reviewers to assign (Tab to multi-select, Enter to confirm)"

    # Use fzf with header at the top, minimal height
    SELECTED_REVIEWERS=$(echo "$POSSIBLE_ASSIGNEES" | fzf -m \
        --height 20% \
        --layout=reverse \
        --inline-info \
        --header-first \
        --header "$FZF_HEADER")

    # If reviewers are selected, update the PR and output success message
    if [ -n "$SELECTED_REVIEWERS" ]; then
        # Convert selected reviewers to comma-separated string
        REVIEWERS_CSV=$(echo "$SELECTED_REVIEWERS" | tr '\n' ',' | sed 's/,$//')
        gh pr edit "$PR_NUMBER" --add-reviewer "$REVIEWERS_CSV"
        echo "Requested review from: $REVIEWERS_CSV"
    else
        echo "No reviewers selected."
    fi
}

# git-cherry-pick: https://github.com/CosmaNeura/cosmaneura/pull/19/commits/4e4c350ddb655acefdfbaad460faeeedb607e941
git-cherry-pick() {
  local url=$1
  local commit=$(basename $url)
  local repo=$(echo $url | sed 's|https://github.com/\([^/]*\)/\([^/]*\)/pull/[0-9]*/commits/.*|\1/\2|')
  local pr_num=$(echo $url | sed 's|https://github.com/[^/]*/[^/]*/pull/\([0-9]*\)/commits/.*|\1|')
  git fetch https://github.com/$repo.git refs/pull/$pr_num/head
  git cherry-pick $commit
}

# Usage:
# Source this in .zshrc or run as a function.
#
# gwt                # List and switch to existing worktree via fzf
# gwt <branch>       # Create new worktree for <branch> (creates branch if not exists) in $GWT_BASE/<project>/<branch>, then cd to it
#
# Environment variables:
# - GWT_BASE: Customize base dir for worktrees (default: ~/Projects/worktrees)
#
# Requires: git, fzf, awk, head
# Debug: Echoes steps for troubleshooting

gwt() {
  local git_path=$(command -v git)
  if [[ -z "$git_path" ]]; then
    echo "git not found in PATH" >&2
    return 1
  fi
  if ! "$git_path" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "Not in a git repo" >&2
    return 1
  fi

  local main_dir=$("$git_path" worktree list | head -1 | awk '{print $1}')
  if [[ -z "$main_dir" ]]; then
    echo "Failed to get main worktree dir" >&2
    return 1
  fi
  local project_name=${main_dir:t}
  local common_git_dir=$("$git_path" rev-parse --git-common-dir)
  common_git_dir=${common_git_dir:A}

  local base_dir=${GWT_BASE:-~/Projects/worktrees}

  get_worktree_for_branch() {
    local target_branch=$1
    local current_path
    while IFS= read -r line; do
      if [[ $line == "worktree "* ]]; then
        current_path=${line#worktree }
      elif [[ $line == "branch refs/heads/$target_branch" ]]; then
        echo "$current_path"
        return 0
      elif [[ -z $line ]]; then
        current_path=
      fi
    done < <("$git_path" worktree list --porcelain)
    return 1
  }

  if (( $# == 0 )); then
    local gray=$'\033[90m'
    local reset=$'\033[0m'
    local green=$'\033[32m'
    local lines=()
    local current_path current_branch ts date_str file wt_name
    while IFS= read -r line; do
      if [[ $line == "worktree "* ]]; then
        current_path=${line#worktree }
      elif [[ $line == "branch "* ]]; then
        current_branch=${line#branch refs/heads/}
      elif [[ $line == "detached" ]]; then
        current_branch="detached"
      elif [[ $line == "bare" ]]; then
        current_branch="bare"
      elif [[ -z $line && -n $current_path ]]; then
        if [[ -z $current_branch ]]; then
          current_branch="unknown"
        fi
        # Get the last commit date from git log
        date_str=$("$git_path" -C "$current_path" log -1 --format=%cd --date=format:%Y-%m-%d 2>/dev/null) || date_str="unknown"
        lines+=("${current_path} ${gray}(${current_branch})${reset} ${green}[${date_str}]${reset}")
        current_path= current_branch=
      fi
    done < <("$git_path" worktree list --porcelain)

    local selected=$(printf '%s\n' "${lines[@]}" | fzf --ansi --height 40% --border)
    if [[ -n "$selected" ]]; then
      local path="${selected%% *}"
      cd "$path" || return 1
    fi
  else
    local branch=$1
    local existing_path=$(get_worktree_for_branch "$branch")
    if [[ -n "$existing_path" ]]; then
      cd "$existing_path" || return 1
    else
      local path=$base_dir/"$project_name"/"$branch"
      /bin/mkdir -p ${path:h}
      if [[ $? -ne 0 ]]; then
        echo "Failed to create parent dir" >&2
        return 1
      fi
      if "$git_path" rev-parse --verify "$branch" >/dev/null 2>&1; then
        "$git_path" worktree add "$path" "$branch"
      else
        "$git_path" worktree add -b "$branch" "$path"
      fi
      if [[ $? -ne 0 ]]; then
        echo "Failed to add worktree" >&2
        return 1
      fi
      cd "$path" || return 1
    fi
  fi
}

github-create-release() {
  # Creates a new GitHub release for the repository of the current directory.
  # It automatically determines the next patch version from git tags.
  # If no version tags (e.g., v1.2.3) exist, it starts at v0.1.0.
  # Release notes are read from standard input.
  #
  # Usage:
  #   echo "My release notes" | github-create-release
  #
  # Dry Run Usage:
  #   github-create-release --dry-run
  #

  # Exit immediately if a command exits with a non-zero status.
  # Treat unset variables as an error.
  # Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero status.
  set -euo pipefail

  # Read stdin first to avoid race conditions in the pipeline.
  # Store in a variable.
  local notes
  if ! [ -t 0 ]; then
    notes=$(cat)
  fi

  # --- Argument Parsing ---
  local DRY_RUN=false
  # Check if the first argument is the --dry-run flag
  if [[ "${1-}" == "--dry-run" ]]; then
    DRY_RUN=true
  fi

  # --- Dependency Checks ---

  if ! command -v gh &> /dev/null; then
    echo "Error: 'gh' (GitHub CLI) is not installed. Please install it to proceed." >&2
    return 1
  fi

  if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    echo "Error: This is not a git repository." >&2
    return 1
  fi

  # --- Version Calculation ---

  echo "Determining next version..."

  # Fetch tags from remote to ensure we have the latest versions
  git fetch --tags

  # Find the latest semantic version tag (e.g., v1.2.3)
  # It handles an optional 'v' prefix.
  local LATEST_TAG=$(git tag --list '[vV][0-9]*.[0-9]*.[0-9]*' | sort -V | tail -n 1)
  local NEW_VERSION
  local LATEST_VERSION
  local MAJOR MINOR PATCH NEW_PATCH
  local VERSION TAG TITLE

  if [[ -z "$LATEST_TAG" ]]; then
    # No tags found, start at 0.1.0
    echo "No previous version tags found. Starting with 0.1.0."
    NEW_VERSION="0.1.0"
  else
    echo "Latest tag found: $LATEST_TAG"
    # Remove 'v' or 'V' prefix
    LATEST_VERSION=${LATEST_TAG#[vV]}

    # Split version into parts using Zsh parameter expansion
    local parts=(${(s:.:)LATEST_VERSION})
    MAJOR=${parts[1]}
    MINOR=${parts[2]}
    PATCH=${parts[3]}

    # Increment the patch number
    NEW_PATCH=$((PATCH + 1))
    NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
  fi

  VERSION=$NEW_VERSION
  TAG="v$VERSION"
  TITLE="Release $VERSION"

  echo "Calculated next version: $VERSION"
  echo # Blank line for readability

  # --- Dry Run Execution ---

  if [ "$DRY_RUN" = true ]; then
    echo "--- Dry Run Mode ---"
    echo "No release will be created."
    echo
    echo "Release Tag:   $TAG"
    echo "Release Title: $TITLE"
    echo "Command that would be executed:"
    echo "  gh release create \"$TAG\" --title \"$TITLE\" --notes-file -"
    echo
    if [[ -n "${notes-}" ]]; then
      echo "--- Release Notes (from stdin) ---"
      echo "$notes"
      echo "--- End of Release Notes ---"
    else
      echo "(Release notes would be read from stdin)"
    fi
    return 0
  fi

  # --- Release Creation ---

  # Check if stdin was provided
  if [[ -z "${notes-}" ]]; then
    echo "Error: Release notes must be provided via stdin." >&2
    echo "Example: echo 'My release notes' | github-create-release" >&2
    return 1
  fi

  echo "Creating release for tag '$TAG'..."

  # Create the GitHub release, piping the stored notes to it.
  echo "$notes" | gh release create "$TAG" \
    --title "$TITLE" \
    --notes-file -

  echo "Successfully created GitHub release for $TAG."
  return 0
}
