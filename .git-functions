# gits: git history search
function gits() {
  # Check if a search string was passed
  if [[ -z "$1" ]]; then
    echo "Usage: gits <string-to-search-in-git-history>"
    return 1
  fi

  local search_string=$1

  git log --all --pickaxe-regex -S "$search_string" --pretty=format:"%C(yellow)%h%Creset -%C(auto)%d%Creset %s %C(green)(%cr) %C(bold blue)<%an>%Creset" | fzf --ansi --no-sort --preview="git show --color=always {1}" --preview-window=right:70%:wrap | awk '{print $1}'
}

function gc() {
  git commit -v -a -m "$*"
}

function gd() {
  git difftool $1 -t Kaleidoscope -y
}

function gbt() {
  git checkout -b $1 --track origin/$1
}

git-add-origin() {
  local remote_name="${1:-origin}"
  local repo_name=$(gh repo view --json name --jq '.name')
  git remote add "$remote_name" "https://github.com/iloveitaly/$repo_name.git"
}

# consumes .git-custom-branch and generates a new `custom` branch
function git-squash-custom-branch {
  # Check if the .git-custom-branch file exists
  if [[ ! -f ".git-custom-branch" ]]; then
    echo "Error: .git-custom-branch file does not exist"
    exit 1
  fi

  # Check for unstaged changes
  if [[ -n "$(git diff --name-only)" ]]; then
    echo "Error: You have unstaged changes. Please commit or stash them."
    exit 1
  fi

  # determine if master is main, or actually master
  local master_branch=$(git branch -l master main | sed 's/^* //' | xargs)

  # Checkout to the master branch
  git checkout $master_branch

  # Pull the latest changes from the master branch
  git pull origin $master_branch

  # Check if the 'custom' branch already exists and delete it if it does
  if git show-ref --verify --quiet refs/heads/custom; then
    git branch -D custom
  fi

  # Read the branch names from the .git-custom-branch file
  branches=($(<.git-custom-branch))

  # Check if there's at least one branch
  if [[ ${#branches[@]} -eq 0 ]]; then
    echo "Error: .git-custom-branch file is empty"
    exit 1
  fi

  # Check if there's more than one branch
  if [[ ${#branches[@]} -eq 1 ]]; then
    echo "Error: .git-custom-branch file contains only one branch (${branches[1]}). At least two branches are required for merging."
    exit 1
  fi

  # Checkout to a new branch named 'custom' from the latest master
  git checkout -b custom

  git merge "${branches[@]}" --no-ff --message "Merged and squashed ${branches[@]}"
}

# TODO should probably remove
# https://blog.takanabe.tokyo/en/2020/04/remove-squash-merged-local-git-branches/
function git-clean-squash-and-merge() (
  set -euo pipefail

  # xargs to trim whitespace https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
  local master_branch=$(git branch -l master main | sed 's/^* //' | xargs)
  echo "Using $master_branch as master"

  git checkout -q $master_branch
  git for-each-ref refs/heads/ "--format=%(refname:short)" | while read branch; do
    local ancestor=$(git merge-base $master_branch $branch)

    if [[ $(git cherry main $(git commit-tree $(git rev-parse $branch'^{tree}') -p $ancestor -m _)) == "-"* ]]; then
      git branch -D $branch
    fi
  done
)
# if a PR is closed when it shouldn't have been, reopen it with one click!
# commonly happens with the annoying stale bots
github_reopen_pr() {
  local PR_URL="$1"
  local REPO PR_NUMBER PR_DETAILS TITLE BODY HEAD_REF

  REPO=$(echo $PR_URL | awk -F '/pull/' '{print $1}' | sed 's|https://github.com/||')
  PR_NUMBER=$(echo $PR_URL | awk -F '/pull/' '{print $2}')
  PR_DETAILS=$(gh pr view $PR_NUMBER --repo $REPO --json title,body,headRefName,headRepositoryOwner)
  BASE_BRANCH=$(gh repo view $REPO --json defaultBranchRef --jq '.defaultBranchRef.name')

  TITLE=$(jq -r .title <<<"$PR_DETAILS")
  BODY=$(jq -r .body <<<"$PR_DETAILS")
  HEAD_REF=$(jq -r .headRefName <<<"$PR_DETAILS")
  HEAD_REPO_OWNER=$(jq -r .headRepositoryOwner.login <<<"$PR_DETAILS")

  gh pr create --web --repo "$REPO" --title "$TITLE" --body "$BODY" --head "$HEAD_REPO_OWNER:$HEAD_REF" --base "$BASE_BRANCH"
}

# add a license to an existing project/repo, both as a license file and license metadata
add_mit_license() {
  # Check if the current folder is tied to a GitHub repository
  if ! gh repo view >/dev/null 2>&1; then
    echo "This folder is not tied to a GitHub repository. Aborting."
    return 1
  fi

  # Check if any LICENSE file exists
  if [[ -e LICENSE || -e LICENSE.md || -e LICENSE.txt ]]; then
    echo "A LICENSE file already exists. Aborting."
    return 1
  fi

  local license_template
  local repo_info
  local repo_name
  local author
  local year

  # Fetch the MIT license template
  license_template=$(gh api /licenses/MIT --jq '.body')

  # Get repository details
  repo_info=$(gh repo view --json nameWithOwner --jq '.nameWithOwner')
  repo_name=$(basename "$repo_info")
  author=$(git config user.name)
  year=$(date +%Y)

  # Replace placeholders in the license template
  local license_content
  license_content=${license_template//\[year\]/$year}
  license_content=${license_content//\[fullname\]/$author}

  # Write the license to LICENSE.md
  echo "$license_content" >LICENSE.md

  echo "MIT License added to the repository."
}

# render readme content on clipboard and replace username and repo
# useful for custom templates I have in my notes
render-git-template() {
  local GH_USERNAME=$(gh repo view --json owner --jq '.owner.login' | tr -d '[:space:]')
  local GH_REPO=$(gh repo view --json name --jq '.name' | tr -d '[:space:]')
  local TEMPLATE=$(pbpaste)

  TEMPLATE=${TEMPLATE//USERNAME/$GH_USERNAME}
  TEMPLATE=${TEMPLATE//REPO/$GH_REPO}
  echo $TEMPLATE | tr -ds '\n' ' '
}

# extracts all file(s) in a git repo path into PWD. Helpful for lifting source from an existing open source project.
# usage: git-extract https://github.com/vantezzen/shadcn-registry-template/blob/main/scripts/
git-extract() {
  local url=$1
  # Extract owner/repo/branch/path from GitHub URL
  local parts=(${(s:/:)${url/https:\/\/github.com\//}})
  local owner=$parts[1]
  local repo=$parts[2]
  local branch=$parts[4]
  local filepath=${(j:/:)parts[5,-1]}

  # Build tarball URL and folder name
  local tarball="https://github.com/$owner/$repo/archive/refs/heads/$branch.tar.gz"
  local foldername="$repo-$branch"

  # Extract just the specified path
  curl -L $tarball | tar xz --strip=1 "$foldername/$filepath"
}

# request review on a PR
gh-assign-reviewer() {
    # Check if there is a PR for the current branch
    PR_NUMBER=$(gh pr view --json number --jq '.number' 2>/dev/null)
    if [ -z "$PR_NUMBER" ]; then
        echo "Error: No PR found for the current branch."
        return 1
    fi

    # Get the PR API URL
    PR_URL=$(gh pr view --json url --jq '.url')

    # Get the list of possible assignees
    POSSIBLE_ASSIGNEES=$(gh api repos/:owner/:repo/assignees --jq '.[].login' | tr ' ' '\n')

    # Prepare the header for fzf with PR URL and instruction
    FZF_HEADER="PR: $PR_URL"$'\n'"Select reviewers to assign (Tab to multi-select, Enter to confirm)"

    # Use fzf with header at the top, minimal height
    SELECTED_REVIEWERS=$(echo "$POSSIBLE_ASSIGNEES" | fzf -m \
        --height 20% \
        --layout=reverse \
        --inline-info \
        --header-first \
        --header "$FZF_HEADER")

    # If reviewers are selected, update the PR and output success message
    if [ -n "$SELECTED_REVIEWERS" ]; then
        # Convert selected reviewers to comma-separated string
        REVIEWERS_CSV=$(echo "$SELECTED_REVIEWERS" | tr '\n' ',' | sed 's/,$//')
        gh pr edit "$PR_NUMBER" --add-reviewer "$REVIEWERS_CSV"
        echo "Requested review from: $REVIEWERS_CSV"
    else
        echo "No reviewers selected."
    fi
}

# Usage: git-cherry-pick <github-pr-commit-url>
#
# Downloads a raw commit patch via the GitHub CLI (gh) and natively 
# applies it to your current branch using a 3-way merge.
#
# Example: 
#   git-cherry-pick https://github.com/iloveitaly/movie-tickets/pull/44/changes/c1856554d577fd405d9ce6adab1024e9b1f1f2dc
git-cherry-pick () {
	local url="$1"
	
	# Parse the repo and commit hash using GNU sed.
	# If the regex fails to find a match, sed will return the unmodified URL.
	local repo=$(echo "$url" | sed -E 's|^https://github\.com/([^/]+/[^/]+)/pull/[0-9]+/(commits|changes)/[a-f0-9]+.*|\1|')
	local commit=$(echo "$url" | sed -E 's|^https://github\.com/[^/]+/[^/]+/pull/[0-9]+/(commits|changes)/([a-f0-9]+).*|\2|')

	# If the output equals the original URL, parsing failed. Print a red error.
	if [[ "$repo" == "$url" || "$commit" == "$url" ]]; then
		printf '\033[1;31mError: Could not detect repo or commit hash from the input.\033[0m\n' >&2
		printf '\033[1;31mExpected format: https://github.com/owner/repo/pull/123/changes/hash\033[0m\n' >&2
		return 1
	fi

	echo "Applying commit $commit from $repo via GitHub API..."
	gh api "repos/$repo/commits/$commit" -H "Accept: application/vnd.github.v3.patch" | git am -3
}
# Usage:
# Source this in .zshrc or run as a function.
#
# gwt                # List and switch to existing worktree via fzf
# gwt <branch>       # Create new worktree for <branch> (creates branch if not exists) in $GWT_BASE/<project>/<branch>, then cd to it
#
# Environment variables:
# - GWT_BASE: Customize base dir for worktrees (default: ~/Projects/worktrees)
#
# Requires: git, fzf, awk, head
# Debug: Echoes steps for troubleshooting

gwt() {
  local git_path=$(command -v git)
  if [[ -z "$git_path" ]]; then
    echo "git not found in PATH" >&2
    return 1
  fi
  if ! "$git_path" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "Not in a git repo" >&2
    return 1
  fi

  local main_dir=$("$git_path" worktree list | head -1 | awk '{print $1}')
  if [[ -z "$main_dir" ]]; then
    echo "Failed to get main worktree dir" >&2
    return 1
  fi
  local project_name=${main_dir:t}
  local common_git_dir=$("$git_path" rev-parse --git-common-dir)
  common_git_dir=${common_git_dir:A}

  local base_dir=${GWT_BASE:-~/Projects/worktrees}

  get_worktree_for_branch() {
    local target_branch=$1
    local current_path
    while IFS= read -r line; do
      if [[ $line == "worktree "* ]]; then
        current_path=${line#worktree }
      elif [[ $line == "branch refs/heads/$target_branch" ]]; then
        echo "$current_path"
        return 0
      elif [[ -z $line ]]; then
        current_path=
      fi
    done < <("$git_path" worktree list --porcelain)
    return 1
  }

  if (( $# == 0 )); then
    local gray=$'\033[90m'
    local reset=$'\033[0m'
    local green=$'\033[32m'
    local lines=()
    local current_path current_branch ts date_str file wt_name
    while IFS= read -r line; do
      if [[ $line == "worktree "* ]]; then
        current_path=${line#worktree }
      elif [[ $line == "branch "* ]]; then
        current_branch=${line#branch refs/heads/}
      elif [[ $line == "detached" ]]; then
        current_branch="detached"
      elif [[ $line == "bare" ]]; then
        current_branch="bare"
      elif [[ -z $line && -n $current_path ]]; then
        if [[ -z $current_branch ]]; then
          current_branch="unknown"
        fi
        # Get the last commit date from git log
        date_str=$("$git_path" -C "$current_path" log -1 --format=%cd --date=format:%Y-%m-%d 2>/dev/null) || date_str="unknown"
        lines+=("${current_path} ${gray}(${current_branch})${reset} ${green}[${date_str}]${reset}")
        current_path= current_branch=
      fi
    done < <("$git_path" worktree list --porcelain)

    local selected=$(printf '%s\n' "${lines[@]}" | fzf --ansi --height 40% --border)
    if [[ -n "$selected" ]]; then
      local path="${selected%% *}"
      cd "$path" || return 1
    fi
  else
    local branch=$1
    local existing_path=$(get_worktree_for_branch "$branch")
    if [[ -n "$existing_path" ]]; then
      cd "$existing_path" || return 1
    else
      local path=$base_dir/"$project_name"/"$branch"
      /bin/mkdir -p ${path:h}
      if [[ $? -ne 0 ]]; then
        echo "Failed to create parent dir" >&2
        return 1
      fi
      if "$git_path" rev-parse --verify "$branch" >/dev/null 2>&1; then
        "$git_path" worktree add "$path" "$branch"
      else
        "$git_path" worktree add -b "$branch" "$path"
      fi
      if [[ $? -ne 0 ]]; then
        echo "Failed to add worktree" >&2
        return 1
      fi
      cd "$path" || return 1
      # Run bootstrap_worktree.sh from main repo if available and executable
      if [[ -x "$main_dir/bootstrap_worktree.sh" ]]; then
        echo "Running bootstrap_worktree.sh..."
        "$main_dir/bootstrap_worktree.sh"
      fi
      # Run bootstrap_worktree if available in justfile
      if just --dry-run bootstrap_worktree >/dev/null 2>&1; then
        echo "Running bootstrap_worktree..."
        just bootstrap_worktree
      fi
    fi
  fi
}

github-create-release() {
  # Creates a new GitHub release for the repository of the current directory.
  # It automatically determines the next patch version from git tags.
  # If no version tags (e.g., v1.2.3) exist, it starts at v0.1.0.
  # Release notes are read from standard input.
  #
  # Usage:
  #   echo "My release notes" | github-create-release
  #
  # Dry Run Usage:
  #   github-create-release --dry-run
  #

  # Exit immediately if a command exits with a non-zero status.
  # Treat unset variables as an error.
  # Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero status.
  set -euo pipefail

  # Read stdin first to avoid race conditions in the pipeline.
  # Store in a variable.
  local notes
  if ! [ -t 0 ]; then
    notes=$(cat)
  fi

  # --- Argument Parsing ---
  local DRY_RUN=false
  # Check if the first argument is the --dry-run flag
  if [[ "${1-}" == "--dry-run" ]]; then
    DRY_RUN=true
  fi

  # --- Dependency Checks ---

  if ! command -v gh &> /dev/null; then
    echo "Error: 'gh' (GitHub CLI) is not installed. Please install it to proceed." >&2
    return 1
  fi

  if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    echo "Error: This is not a git repository." >&2
    return 1
  fi

  # --- Version Calculation ---

  echo "Determining next version..."

  # Fetch tags from remote to ensure we have the latest versions
  git fetch --tags

  # Find the latest semantic version tag (e.g., v1.2.3)
  # It handles an optional 'v' prefix.
  local LATEST_TAG=$(git tag --list '[vV][0-9]*.[0-9]*.[0-9]*' | sort -V | tail -n 1)
  local NEW_VERSION
  local LATEST_VERSION
  local MAJOR MINOR PATCH NEW_PATCH
  local VERSION TAG TITLE

  if [[ -z "$LATEST_TAG" ]]; then
    # No tags found, start at 0.1.0
    echo "No previous version tags found. Starting with 0.1.0."
    NEW_VERSION="0.1.0"
  else
    echo "Latest tag found: $LATEST_TAG"
    # Remove 'v' or 'V' prefix
    LATEST_VERSION=${LATEST_TAG#[vV]}

    # Split version into parts using Zsh parameter expansion
    local parts=(${(s:.:)LATEST_VERSION})
    MAJOR=${parts[1]}
    MINOR=${parts[2]}
    PATCH=${parts[3]}

    # Increment the patch number
    NEW_PATCH=$((PATCH + 1))
    NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
  fi

  VERSION=$NEW_VERSION
  TAG="v$VERSION"
  TITLE="Release $VERSION"

  echo "Calculated next version: $VERSION"
  echo # Blank line for readability

  # --- Dry Run Execution ---

  if [ "$DRY_RUN" = true ]; then
    echo "--- Dry Run Mode ---"
    echo "No release will be created."
    echo
    echo "Release Tag:   $TAG"
    echo "Release Title: $TITLE"
    echo "Command that would be executed:"
    echo "  gh release create \"$TAG\" --title \"$TITLE\" --notes-file -"
    echo
    if [[ -n "${notes-}" ]]; then
      echo "--- Release Notes (from stdin) ---"
      echo "$notes"
      echo "--- End of Release Notes ---"
    else
      echo "(Release notes would be read from stdin)"
    fi
    return 0
  fi

  # --- Release Creation ---

  # Check if stdin was provided
  if [[ -z "${notes-}" ]]; then
    echo "Error: Release notes must be provided via stdin." >&2
    echo "Example: echo 'My release notes' | github-create-release" >&2
    return 1
  fi

  echo "Creating release for tag '$TAG'..."

  # Create the GitHub release, piping the stored notes to it.
  echo "$notes" | gh release create "$TAG" \
    --title "$TITLE" \
    --notes-file -

  echo "Successfully created GitHub release for $TAG."
  return 0
}

# deletes all local branches that have no differences with master (i.e. have been squashed into master)
# Usage:
#  git-rm-merged [--dry-run|-n] [target-branch]
git-rm-merged() {
  emulate -L zsh
  local dry_run=0
  local target_branch="master"
  local target_branch_set=0
  local current_branch

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run|-n) dry_run=1 ;;
      -*) print -P "%F{red}Unknown option: $1%f"; return 1 ;;
      *) target_branch="$1"; target_branch_set=1 ;;
    esac
    shift
  done

  # Validation
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    print -P "%F{red}Error: Not a git repository.%f"
    return 1
  fi

  if (( ! target_branch_set )); then
    if ! git show-ref --verify --quiet "refs/heads/$target_branch"; then
      if git show-ref --verify --quiet "refs/heads/main"; then
        target_branch="main"
      fi
    fi
  fi

  if ! git show-ref --verify --quiet "refs/heads/$target_branch"; then
    print -P "%F{red}Error: Target branch '$target_branch' does not exist.%f"
    return 1
  fi

  current_branch=$(git rev-parse --abbrev-ref HEAD)

  # 1. PRE-CALCULATE LOCKED BRANCHES
  # We do this BEFORE switching branches. This captures the branch you are currently
  # standing on, plus any branches checked out in other folders.
  local -A locked_branches

  # Parse `git worktree list --porcelain` to find lines starting with "branch refs/heads/"
  while read -r line; do
    # Strip the "branch refs/heads/" prefix to get the short name
    local branch_name=${line#branch refs/heads/}
    locked_branches[$branch_name]=1
  done < <(git worktree list --porcelain | grep "^branch refs/heads/")

  {
    if [[ "$current_branch" != "$target_branch" ]]; then
      print -P "%F{blue}Checking out '$target_branch' to analyze merge states...%f"
      git checkout -q "$target_branch" || return 1
    fi

    while read -r branch; do
      [[ "$branch" == "$target_branch" ]] && continue

      # 2. CHECK WORKTREE LOCK
      if (( ${locked_branches[$branch]} )); then
        # Optional: Print a message if in dry-run or verbose mode so you know why it wasn't deleted
        if (( dry_run )); then
           print -P "%F{cyan}[SKIP] '$branch' is currently checked out in a worktree.%f"
        fi
        continue
      fi

      local merge_base=$(git merge-base "$target_branch" "$branch")
      local tree_hash=$(git rev-parse "$branch^{tree}")
      local synthetic_commit=$(git commit-tree "$tree_hash" -p "$merge_base" -m "synthetic-check")

      if [[ $(git cherry "$target_branch" "$synthetic_commit") == "-"* ]]; then
        if (( dry_run )); then
          print -P "%F{yellow}[DRY RUN] Would delete:%f $branch"
        else
          print -P "%F{red}Deleting merged branch:%f $branch"
          git branch -D "$branch"
        fi
      fi
    done < <(git for-each-ref refs/heads/ "--format=%(refname:short)")

  } always {
    if [[ -n "$current_branch" && "$current_branch" != "$target_branch" ]]; then
       if git show-ref --verify --quiet "refs/heads/$current_branch"; then
          print -P "%F{blue}Returning to '$current_branch'...%f"
          git checkout -q "$current_branch"
       else
          print -P "%F{yellow}Original branch '$current_branch' was deleted or not found. Staying on '$target_branch'.%f"
       fi
    fi
  }
}

# mergetool does *not* open the actual files, which means the AI tools for the project won't work
# this attempts to open all merge files in the project folder in vs code
git-mergetool-vscode() {
  repo=$(git rev-parse --show-toplevel)
  files=($(git diff --name-only --diff-filter=U))
  code --reuse-window "$repo" "${files[@]}"
}

# rebase on the current branch's upstream, preferring 'upstream' remote if it exists
gpb() {
  local branch
  local remote

  branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || return 1

  if git remote get-url upstream >/dev/null 2>&1; then
    remote="upstream"
  elif git remote get-url origin >/dev/null 2>&1; then
    remote="origin"
  else
    print -P "%F{red}Error: Neither 'upstream' nor 'origin' remotes exist.%f" >&2
    return 1
  fi

  g pull --rebase "$remote" "$branch"
}