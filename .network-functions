###########################
# Proxy Helpers
###########################

# all webshare proxies are socks5
# https://help.webshare.io/en/articles/8370540-are-your-proxies-socks-or-http


get-socks-proxy() {
  set -e
  local webshare_token;

  webshare_token=$(op read "op://Assistant/WEBSHARE Scraping Proxy Login/API doc key")

  local proxy_auth=$(
    http "https://proxy.webshare.io/api/v2/proxy/list/?mode=direct" "Authorization: Token $webshare_token" | \
      jq -r '.results | map(select(.country_code == "US")) | .[0] | "socks5://\(.username):\(.password)@\(.proxy_address):\(.port)"'
  )

  for id in $(curl -s -H "Authorization: Token $webshare_token" \
    "https://proxy.webshare.io/api/v2/proxy/ipauthorization/" | \
    jq -r '.results[].id'); do
    curl -s -X DELETE -H "Authorization: Token $webshare_token" \
      "https://proxy.webshare.io/api/v2/proxy/ipauthorization/$id/" 1>/dev/null
    echo "Deleted IP authorization ID: $id" >&2
  done

  # authorize the ip to avoid having to pass the correct username and password, which canary does not support
  local my_ip
  my_ip=$(curl -s https://ifconfig.me/ip | tr -d '\n')
  http POST https://proxy.webshare.io/api/v2/proxy/ipauthorization/ \
    ip_address="$my_ip" \
    Authorization:"$webshare_token" \
    Content-Type:application/json

  echo $proxy_auth
}

proxy_socks() {
  # Use local variables to avoid polluting the global shell environment
  local cmd api_response config_command token

  token=$(op read "op://Assistant/WEBSHARE Scraping Proxy Login/API doc key")

  echo "Fetching proxy list and filtering for US proxies..." >&2

  # 1. Call the Webshare API to get the list of proxies
  api_response=$(http --ignore-stdin "https://proxy.webshare.io/api/v2/proxy/list/?mode=direct" "Authorization: Token $token")

  # Check if the API call was successful
  if [[ $? -ne 0 ]]; then
    echo "Error: Failed to fetch proxy list from the Webshare API." >&2
    return 1
  fi

  # 2. Use jq to filter for US proxies and format the nanoproxy command
  config_command=$(echo "$api_response" | jq -r '
    # Assign the filtered array of US-based proxies to a variable using "as"
    ([.results[] | select(.country_code == "US")]) as $us_proxies
    |
    if ($us_proxies | length) > 0 then
      # Select the first proxy from the filtered US list
      $us_proxies[0] |
      "ADDR=\":1080\" \\\n" +
      "NETWORK=\"tcp\" \\\n" +
      "UPSTREAM_TYPE=\"socks5\" \\\n" +
      "TZ=\"America/New_York\" \\\n" +
      "UPSTREAM_ADDRESS=\"\(.proxy_address):\(.port)\" \\\n" +
      "CREDENTIALS=\"\(.username):\(.password)\" \\\n" +
      "nanoproxy"
    else
      # Return a specific error string if no US proxies are found
      "ERROR_NO_US_PROXIES_FOUND"
    end
  ')

  # 3. Check for errors from the jq parsing step
  if [[ "$config_command" == "ERROR_NO_US_PROXIES_FOUND" ]]; then
    echo "Error: No US proxies were found in the API response." >&2
    return 1
  fi

  # 4. Print the final, formatted command to standard output
  echo "$config_command"
}

proxy-chrome-canary() {
  local proxy_auth
  proxy_auth=$(get-socks-proxy)
  # Extract protocol, IP, and port (remove username and password)
  local proxy_url
  proxy_url=$(echo "$proxy_auth" | sed -E 's#(socks5)://[^@]+@([^:]+):([0-9]+)#\1://\2:\3#')
  open -a "Google Chrome Canary" --args --proxy-server="$proxy_url"
}

# set ethernet to use the socks proxy
set-socks-proxy() {
  # from webshare
      # jq -r '.results | map(select(.country_code == "US")) | .[0] | "\(.proxy_address) \(.port) On \(.username) \(.password)"'
  # expected format: networksetup -setsocksfirewallproxy <networkservice> <domain> <port number> <authenticated> <username> <password>

  # eval "networksetup -setsocksfirewallproxy "Wi-Fi" $proxy_auth"

  networksetup -setsocksfirewallproxystate "Ethernet" On
  eval "networksetup -setsocksfirewallproxy "Ethernet" $(get-socks-proxy)"
}

clear-socks-proxy() {
  networksetup -setsocksfirewallproxy "Wi-Fi" Empty
  networksetup -setsocksfirewallproxystate "Wi-Fi" Off

  networksetup -setsocksfirewallproxy "Ethernet" Empty
  networksetup -setsocksfirewallproxystate "Ethernet" Off
}

###########################
# Randomize Mac Address
###########################

# Add to ~/.zshrc
randomize_mac() {
  interface=${1:-en0}
  # Get current MAC
  current_mac=$(ifconfig "$interface" | grep ether | awk '{print $2}')
  # Check if backup exists
  if [ -f ~/.mac_address_backup ]; then
    stored_mac=$(cat ~/.mac_address_backup)
    if [ "$current_mac" != "$stored_mac" ]; then
      echo "MAC already randomized. Generating new random MAC."
    fi
  else
    # Store original MAC if no backup exists
    echo "$current_mac" > ~/.mac_address_backup
  fi
  # Generate random MAC (ensure valid unicast)
  new_mac=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//; s/^./2/')
  # Set new MAC
  sudo ifconfig "$interface" lladdr "$new_mac"
  echo "Original MAC saved. New MAC: $new_mac"
}

restore_mac() {
  interface=${1:-en0}
  # Check if backup file exists
  if [ -f ~/.mac_address_backup ]; then
    original_mac=$(cat ~/.mac_address_backup)
    sudo ifconfig "$interface" lladdr "$original_mac"
    echo "Restored MAC: $original_mac"
    # Remove backup file
    rm ~/.mac_address_backup
  else
    echo "No MAC backup found. Reboot to reset to hardware default."
  fi}